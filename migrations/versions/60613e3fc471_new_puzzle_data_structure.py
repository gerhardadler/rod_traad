"""new puzzle data structure

Revision ID: 60613e3fc471
Revises: 79fa76ad5e9e
Create Date: 2025-07-04 17:15:45.104088

"""

import datetime
import json
from typing import Any, Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel


# revision identifiers, used by Alembic.
revision: str = '60613e3fc471'
down_revision: Union[str, None] = '79fa76ad5e9e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def get_solution_id(puzzles: Any, words: list[str]):
    for puzzle in puzzles:
        for solution_id, solution_words in enumerate(puzzle.data['solutions'].values()):
            if sorted(solution_words) == sorted(words):
                return solution_id


def convert_old_puzzle_data(old_data: dict[str, Any]):
    grid = old_data['grid']
    solutions_dict = old_data['solutions']

    # Flatten the grid into a single list and create word objects
    words: list[dict[str, Any]] = []
    word_lookup: dict[str, int] = {}
    position = 0

    for row in grid:
        for word_name in row:
            word_obj = {'id': position, 'name': word_name, 'position': position}
            words.append(word_obj)
            word_lookup[word_name] = position
            position += 1

    # Create solution objects using word IDs
    solutions: list[dict[str, Any]] = []
    for idx, (name, word_names) in enumerate(solutions_dict.items()):
        word_ids = [word_lookup[word] for word in word_names]
        solutions.append(
            {
                'name': name,
                'difficulty': idx,  # assuming the order defines difficulty
                'words': word_ids,
            }
        )

    return {'solutions': solutions, 'words': words}


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###

    temporary_metadata = sa.MetaData()

    class OldPuzzle(sqlmodel.SQLModel, table=True):
        __tablename__ = 'puzzle'
        metadata = temporary_metadata

        id: str | None = sqlmodel.Field(default=None, primary_key=True)
        number: int | None = sqlmodel.Field(default=None, nullable=True, unique=True)
        data: dict[str, Any] = sqlmodel.Field(
            default_factory=dict, sa_column=sqlmodel.Column(sqlmodel.JSON)
        )
        date: datetime.date | None

    class OldGuess(sqlmodel.SQLModel, table=True):
        __tablename__ = 'guess'
        metadata = temporary_metadata

        id: int | None = sqlmodel.Field(default=None, primary_key=True)
        session_id: int = sqlmodel.Field(foreign_key="gamesession.id")
        words: list[str] = sqlmodel.Field(
            default_factory=list, sa_column=sqlmodel.Column(sqlmodel.JSON)
        )
        correct: bool = sqlmodel.Field(default=False)

    conn = op.get_bind()
    session = sqlmodel.Session(conn)
    old_puzzles = session.exec(sqlmodel.select(OldPuzzle)).all()
    old_guesses = session.exec(sqlmodel.select(OldGuess)).all()

    with op.batch_alter_table('guess', schema=None) as batch_op:
        batch_op.add_column(sa.Column('solution', sa.Integer(), nullable=True))
        batch_op.drop_column('correct')

    with op.batch_alter_table('puzzle', schema=None) as batch_op:
        batch_op.create_unique_constraint(batch_op.f('uq_puzzle_number'), ['number'])

    for guess in old_guesses:
        conn.execute(
            sa.text("UPDATE guess SET solution = :solution WHERE id = :id"),
            {"id": guess.id, "solution": get_solution_id(old_puzzles, guess.words)},
        )

    for puzzle in old_puzzles:
        conn.execute(
            sa.text("UPDATE puzzle SET data = :data WHERE id = :id"),
            {"id": puzzle.id, "data": json.dumps(convert_old_puzzle_data(puzzle.data))},
        )

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""

    raise NotImplementedError('Not implemented downgrade')

    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('puzzle', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('uq_puzzle_number'), type_='unique')

    with op.batch_alter_table('guess', schema=None) as batch_op:
        batch_op.add_column(sa.Column('correct', sa.BOOLEAN(), nullable=False))
        batch_op.drop_column('solution')

    # ### end Alembic commands ###
